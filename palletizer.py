"""Palletization pattern generator.

This module provides simple utilities for generating pallet layer
patterns from pallet and product dimensions. It can load/save the
`pally` JSON format used by PAL-IN and myrobot.cloud.

Usage example:

    python palletizer.py --pallet-length 1200 --pallet-width 800 \
        --box-length 450 --box-width 310 --layers 5 --output out.json

The script will create `out.json` describing a pallet project with a
single layer type generated as a grid. Each additional layer in the
project references that layer type and alternating layers can be
mirrored using the `--alternate` flag.

The goal of this script is not to replicate the full functionality of
the web interface but to provide a foundation for creating and editing
pallet patterns programmatically.
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass, asdict
from typing import List, Dict


@dataclass
class Dimensions:
    length: int
    width: int
    height: int = 0
    palletHeight: int | None = None

    def to_json(self) -> Dict[str, int]:
        data = {"length": self.length, "width": self.width}
        if self.height:
            data["height"] = self.height
        if self.palletHeight is not None:
            data["palletHeight"] = self.palletHeight
        return data


@dataclass
class ProductDimensions:
    length: int
    width: int
    height: int
    weight: int | float = 0

    def to_json(self) -> Dict[str, int | float]:
        return {
            "length": self.length,
            "width": self.width,
            "height": self.height,
            "weight": self.weight,
        }


@dataclass
class PatternBox:
    x: int
    y: int
    r: List[int]

    def to_json(self) -> Dict[str, object]:
        return {"x": self.x, "y": self.y, "r": self.r, "g": [], "f": 1}


@dataclass
class LayerType:
    name: str
    pattern: List[PatternBox]
    alt_pattern: List[PatternBox] | None = None

    def to_json(self) -> Dict[str, object]:
        data = {
            "name": self.name,
            "class": "layer",
            "pattern": [b.to_json() for b in self.pattern],
        }
        if self.alt_pattern:
            data["altPattern"] = [b.to_json() for b in self.alt_pattern]
            data["approach"] = "normal"
            data["altApproach"] = "normal"
        return data


@dataclass
class Project:
    name: str
    dimensions: Dimensions
    product: ProductDimensions
    layer_type: LayerType
    layers: int
    units: str = "mm"

    def to_json(self) -> Dict[str, object]:
        return {
            "name": self.name,
            "description": "Generated by palletizer.py",
            "units": self.units,
            "dimensions": self.dimensions.to_json(),
            "productDimensions": self.product.to_json(),
            "overhangSides": 0,
            "overhangEnds": 0,
            "maxGrip": 0,
            "guiSettings": {"PPB_VERSION_NO": "3.1.1"},
            "layerTypes": [self.layer_type.to_json()],
            "layers": [self.layer_type.name for _ in range(self.layers)],
        }


# ---------------------------------------------------------------------------
# Pattern generation helpers
# ---------------------------------------------------------------------------

def generate_grid_pattern(
    pallet_length: int,
    pallet_width: int,
    box_length: int,
    box_width: int,
) -> List[PatternBox]:
    """Generate a simple grid pattern.

    Boxes are placed without gaps starting in the upper-left corner.
    Orientation is fixed at 0 degrees. Coordinates specify the
    upper-left corner of each box.
    """
    cols = pallet_length // box_length
    rows = pallet_width // box_width
    pattern: List[PatternBox] = []
    for r in range(rows):
        for c in range(cols):
            pattern.append(PatternBox(x=c * box_length, y=r * box_width, r=[0]))
    return pattern


def mirror_pattern(pattern: List[PatternBox], pallet_length: int, box_length: int) -> List[PatternBox]:
    """Mirror a pattern horizontally to create an alternate layout."""
    mirrored: List[PatternBox] = []
    for b in pattern:
        mirrored.append(
            PatternBox(
                x=pallet_length - box_length - b.x,
                y=b.y,
                r=b.r,
            )
        )
    return mirrored


# ---------------------------------------------------------------------------
# Command line interface
# ---------------------------------------------------------------------------

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate pallet patterns")
    parser.add_argument("--pallet-length", type=int, required=True, help="Pallet length")
    parser.add_argument("--pallet-width", type=int, required=True, help="Pallet width")
    parser.add_argument("--pallet-height", type=int, default=0, help="Maximum pallet load height")
    parser.add_argument("--box-length", type=int, required=True, help="Box length")
    parser.add_argument("--box-width", type=int, required=True, help="Box width")
    parser.add_argument("--box-height", type=int, default=0, help="Box height")
    parser.add_argument("--box-weight", type=float, default=0.0, help="Box weight")
    parser.add_argument("--layers", type=int, default=1, help="Number of layers")
    parser.add_argument("--alternate", action="store_true", help="Generate mirrored alternate pattern")
    parser.add_argument("--name", default="pallet", help="Project name")
    parser.add_argument("--output", default="pallet-project.json", help="Output JSON file")
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    dims = Dimensions(
        length=args.pallet_length,
        width=args.pallet_width,
        palletHeight=args.pallet_height,
    )
    product = ProductDimensions(
        length=args.box_length,
        width=args.box_width,
        height=args.box_height,
        weight=args.box_weight,
    )

    base_pattern = generate_grid_pattern(
        args.pallet_length,
        args.pallet_width,
        args.box_length,
        args.box_width,
    )

    alt_pattern = None
    if args.alternate:
        alt_pattern = mirror_pattern(base_pattern, args.pallet_length, args.box_length)

    layer = LayerType(name="Layer 1", pattern=base_pattern, alt_pattern=alt_pattern)
    project = Project(
        name=args.name,
        dimensions=dims,
        product=product,
        layer_type=layer,
        layers=args.layers,
    )

    with open(args.output, "w", encoding="utf-8") as fh:
        json.dump(project.to_json(), fh, indent=2)

    print(f"Generated project written to {args.output}")


if __name__ == "__main__":
    main()
